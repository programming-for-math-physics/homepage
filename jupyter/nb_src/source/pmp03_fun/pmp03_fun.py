""" md

# 関数定義

プログラムを(高機能電卓を越えて)プログラムたらしめる最たるものがこの「関数定義」(自分で好きな関数を定義できる機能)である. 

関数はこれまでも$|x|$ (`abs`), $\sin$ (`math.sin`), $\exp$ (`math.exp`) など色々なものが「使える」ということを述べたがそれらは最初からPythonに備わっていた関数である.

この節のポイントは__自分で関数を新たに定義でき__, それを上記のような関数と同じように使える, ということである.

手始めに, 以下は与えられた入力$x$に対して$x^2$を計算する関数(squareと名付けた)の定義である.

"""

""" code """
def square(x):
    return x * x
""" """

""" md
これは数学でいうところの定義:

定義: 関数square を 
$$ {\rm square}(x) \equiv x * x $$
と定義する.

というのと同じである.

一旦このセルを(`Shift + Enter`で)実行すると, squareという名前(実は変数. 後述)が上記の関数として定義され, 以下のように呼び出せるようになる.
"""

""" code """
square(30)
""" """

""" code """
square(50)
""" """

""" md 

もうひとつ例を見せておく. 以下は, 3辺の長さ$a, b, c$を入力として与えられたら, その三角形の面積をヘロンの公式で求める関数である.

"""

""" code """
def helon(a, b, c):
    s = (a + b + c) / 2
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5
""" """

""" md 

一度これが定義されれば以下のように任意の3数を3辺の長さに持つ三角形の面積が計算できる

"""

""" code """
helon(7, 8, 9)
""" """

""" code """
helon(1, 1, 1)
""" """

""" md

## 関数定義にまつわる用語

上記関数定義において,

 * helon を関数定義の「関数名」
 * `s = (a + b + c) / 2` と `return (s * (s - a) * (s - b) * (s - c)) ** 0.5` は関数定義の「本体」
 * a, b, c は入力を受け取る変数であり, それらを「パラメータ」

などと呼ぶ.

さてこのhelon関数の定義を見てもわかるとおり, 関数定義の本体にも複数の文を並べて書くことができる. そして想像通り, それらは関数が使われ(呼び出され)たら, 上から順に実行されていく(セルに複数の文を書いたときの規則と同じ). 
"""

""" md

## return文

さて, square関数定義内の
```
    return x * x
```
やhelon関数定義内の
```
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5
```
における, `return`という記法は何を意味するのだろうか. それは,

 * その関数呼び出しの値を, `return`以下にかかれている式を評価した結果とする (「式」を評価した結果を返す(returnする)
 * その時点で関数の中身の実行を終了する(returnの後ろに続く文があっても実行されない)

という二つの効果を持つ. したがって多くの関数の見た目は, いくつかの文が並んでおり最後の行がreturn文という形をしているが, 後に述べるように, 条件文(if)や繰り返し(for)を伴う関数では, そうではない(ことに実質的な意味がある)場合もある. そのような例は後に見ることにして今はとりあえず, 規則の理解に集中する.

例えば, 意味がないのを承知で, 以下のような関数定義を書いたら,

"""

""" code """
def f(x):
    return x * x * x
    return x * x
""" """

""" md

これは $x^3$ を計算する関数の定義になる. この関数が呼び出されたら, 最初の `return x * x * x` が実行された時点で関数の実行は終了し, 返り値(結果)は `x * x * x`を計算した値で確定する.

上のような関数定義をわざわざ書きたくなる人はいないだろうが, 逆のパターン, return文を書き忘れる, という間違いはおそらく多くの人が一度や二度は体験する. 

例えばヘロンの公式で三角形の面積を計算する関数を書くつもりで,
"""

""" code """
def helon(a, b, c):
    s = (a + b + c) / 2
    (s * (s - a) * (s - b) * (s - c)) ** 0.5
""" """

""" md

のように書いてしまったとする. そのような場合の規則は,

return文を実行することなく関数の中身の実行が終了した場合は, `None`という結果が帰る

というものである.

「`None`って一体なに? `None`という結果が返ると言われても... だから何?」としか言えない, という疑問はもっともである. ともかく`None`は, 1とか2.3とか, TrueとかFalseとか, そういう値の一種なのだがそれらのどれとも違う「変な値」とだけ思っておけば良い. そして, `None`に対して, 数を対象とした演算(+ とか)を行うと以下のようなエラーが出る, というところが重要である.

"""

""" code """
# error
None + 3
""" """

""" md

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-12-7cf993271d73> in <module>
----> 1 None + 3

TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
```
"""

""" md

わざわざこんなことを書く人はいないが, ポイントは, return の書き忘れによって結果的にこのような演算をしてしまうことがある, ということ.

"""

""" code """
# error
def helon(a, b, c):
    s = (a + b + c) / 2
    (s * (s - a) * (s - b) * (s - c)) ** 0.5

helon(3, 4, 5) + 1
""" """

""" md

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-13-8f1d97331d6c> in <module>
      4 
      5 
----> 6 helon(3, 4, 5) + 1

TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
```

"""
    
""" md 

__自ら, `None`などと書いた覚えがないのにこのようなエラーが現れたら, returnの書き忘れを疑う__と良い

"""

""" md 

## 複数の文を並べるときの記法上の規則

関数定義の本体に複数の文が書けると述べた.

```
def helon(a, b, c):
    s = (a + b + c) / 2
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5
```

例えばこの定義では, `s = (a + b + c) / 2`と`return (s * (s - a) * (s - b) * (s - c)) ** 0.5`が本体を構成する文であるが, このように複数の文を並べる時に, 

 1. 必ず1文字以上字下げをする
 1. 字下げの量(文字数)を全て揃える

という規則がある. つまり,
"""

""" code """
# error
def helon(a, b, c):
    s = (a + b + c) / 2
      return (s * (s - a) * (s - b) * (s - c)) ** 0.5
""" """

""" md
という書き方はしてはならない(規則2に違反)し,
"""

""" code """
# error
def helon(a, b, c):
s = (a + b + c) / 2
return (s * (s - a) * (s - b) * (s - c)) ** 0.5
""" """

""" md
もダメ(規則1に違反).

以下はどちらもOK (字下げの量は自由)
"""

""" code """
def helon(a, b, c):
 s = (a + b + c) / 2
 return (s * (s - a) * (s - b) * (s - c)) ** 0.5
""" """

""" code """
def helon(a, b, c):
       s = (a + b + c) / 2
       return (s * (s - a) * (s - b) * (s - c)) ** 0.5
""" """

""" md 

字下げをするときは, スペースキーを何度も押すのではなく, Tabキーを1回押すのが推奨.

常に一貫した量の字下げをしてくれる

"""

""" code """
def helon(a, b, c):
    s = (a + b + c) / 2
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5
""" """

""" md 

# これまでに登場した式・文のまとめ

さてこれまでに学んだことを整理すると, 

 * (様々な)式. 算術式, 関数呼び出し式など
 * 変数の概念. それが式の中で使えること
 * import
 * 代入文
 * 関数定義
 * return文

などがある. 

それらを流れの中で用法とともに学んできたが, ここで一度, 「文法」--- どのような文字列がプログラムとしてとりあえず合法か = セルの中に書けるもの --- をきちんと整理しておく.

前述の通りプログラミング言語は数学や英語の記法を人間に読ませる場合と違い, 読者が多少の間違いを補って読んでくれることを期待できない. その杓子定規さが初学者を遠ざける一方で, 以下のような記法で厳密に定義されていて, 人間の言語のような細かな例外規則がなく, 覚えることは少ない. 例えば英語では, 5文型なるものを習う

```
<文> ::= <主語> <動詞句>  (S V) 
       | <主語> <動詞句> <補語> (S V C)
       | <主語> <動詞句> <目的語> (S V O)
       | <主語> <動詞句> <目的語> <目的語> (S V O O)
       | <主語> <動詞句> <目的語> <補語> (S V O C)
```

これらは一見すると, 英文法というものを簡単なものだと思わせてくれる公式だが, 実際の英語学習者は, この文型に収まらない文がたくさんある(例えば命令文)ことを知っているし, この文型に収まっていても文法的に間違っている文がたくさんある(例えば呼応: This are a pen が間違いとか)ことも知っている. 

上記の規則をより精密にしていって, 例えば

```
<文> ::= <1,2人称単数主語> <1,2人称単数動詞>
       | <3人称単数主語> <3人称単数動詞>
       | ...
```

のように精緻化していっても, 結局例外が生じ, 果てしのない話になっていくことは目に見えている. 

したがって英語学習者は, これらはせいぜい理解を助けるための道具に過ぎないと思って, 「あまり本気にはしていない」というのが本当のところだろう.

それに対してプログラミング言語は人工的な言語であるし, 入力されたプログラムの文法的な正しさも, その実行規則も, コンピュータ(プログラム)で実現するものであるから, 文法を厳密に, 比較的短く書き表すことが可能である(というよりも, そうでないとそれをコンピュータで読み取ったり実行したりすることがやりにくくて仕方がないので, わざわざややこしい例外を作ったりしないというだけである). 

したがって上記の英語5文型のノリで書いたものが「厳密に」正しい文法になる.

これまでに説明した範囲を文法規則で表したものが以下になる.

```
<セル> ::= <文>*  

<文> ::= <代入文>
     | <関数定義文>
     | <リターン文>
     | <import文>
     | <式>

<代入文> ::= <完全名> = <式>

<関数定義文> ::= def <名前> '(' ')' : <文>+
               | def <名前> '(' <名前> ( ',' <名前> )* ) ':' <文>+

<リターン文> ::= return <式>

<import文> ::= import <完全名> (as 名前)?
             | from <完全名> import 名前 (, 名前)*
             | from <完全名> import '*'

<式> ::= <数値リテラル>
       | True
       | False
       | None
       | <完全名>
       | <単項演算式>
       | <二項演算式>
       | <関数呼び出し式>
       | '(' <式> ')'

数値リテラル ::= 省略 (1, 234, 567.8, 6.23e23 など)

完全名 ::= 名前 ( '.' 名前 )*

名前 ::= A-Za-z_ (A-Za-z0-9_)*  (アルファベット, 数字, _の並び. ただし一文字目はアルファベットまたは _ . 変数名の規則で述べたとおり)

単項演算式 ::= 単項演算子 式 
単項演算子 ::= '-' | not

二項演算式 ::= 式 二項演算子 式
二項演算子 ::= 以下のどれか '+', '-', '*', '/', '//', '%', '**', '<', '<=', '>=', '>', '==', '!=', and, or

```

これは, 眺めているだけでなんとなく意味はわかると思うが, 一応説明.

また, 本物のPythonの全文法(ここで習わないものを含めて)はここにある. これを見てマスターせよということではなく, プログラミング言語の文法をきちんと定義するためにこのような表記を世の中でもしている, ということを見るために一度見てみると良い, ということ.

これを読むときに注意すべき点

 * `<...> ::= ...` のような表記は, 「文(として正しい文字列)は, 右辺に書かれたような文字列である」という言明を表している. 例えば,
```
<リターン文> ::= return <式>
```
は, 「リターン文として正しい文字列というものは, return の後に式(として正しい文字列)を並べたものである」と読む. したがって, xyz という文字列が正しい式であるならば(実際そうである), return xyz は正しいリターン文, ということになる
 * ::= の右辺が | で区切られている場合, 「それらのどれか」という意味になる. 例えば,
```
<文> ::= 
```
の右辺には5つの選択肢が | で区切って書かれており, これはすでに見たように, 文(として正しい文字列)は, 代入文(として正しい文字列), 関数定義文(として正しい文字列), リターン文(として正しい文字列), import文(として正しい文字列), 式(として正しい文字列), のどれかである, ということを示している. 
 * * は, 0個以上の並び, + は1個以上の並びを表している. 例えば,



は数学で言うところの square($x$) $\equiv x * x$ という定義をするための, Python流の (Pythonの文法規則に則った)書き方である. その文法規則とは以下のようなものである.

```
def 関数名(変数名, 変数名, ..., 変数名):
    文
    ...
    文
```

"""


""" md label=prob,ans

#*P 内積

4つの数 $a, b, c, d$ を受け取り, ベクトル $(a, b)$ と $(c, d)$の内積を計算する
関数, `inner(a, b, c, d)` を書き, 適当な例を使って確かめよ.
"""

""" code points=1 w """
""" """

""" code label=ans """
def inner(a,b,c,d):
    return a * c + b * d
""" """

""" code points=1 label=prob,ans """
# test
assert(inner(1,2,3,4) == 11)
assert(inner(3,4,3,4) == 25)
""" """

""" md label=prob,ans

#*P 2次方程式の解

$a, b, c$を与えられ, 2次方程式

$$ ax^2 + bx + c = 0 $$

の解(のひとつ; どちらでもよい)を返す関数
`solve_q(a, b, c)`を書け. ただし, $a \neq 0$
を仮定して良い.
$\sqrt{\cdot}$を計算する関数は`math`モジュール内の`sqrt`関数．

上記方程式が実数解を持つことを仮定しても良いが,
そう仮定する代わりに, `cmath`モジュールの`sqrt`関数(負の数の$\sqrt{\cdot}$を計算できる)を使っても良い

"""

""" code points=1 w """
""" """

""" code label=ans """
import cmath
def solve_q(a,b,c):
    d = cmath.sqrt(b * b - 4 * a * c)
    x = (-b + d) / (2 * a)
    return x
""" """

""" code points=1 label=prob,ans """
# test
def check_q(a, b, c):
    x = solve_q(a, b, c)
    return abs(a * x * x + b * x + c) < 1.0e-3

assert(check_q(1,5,3))
assert(check_q(3,4,-1))
""" """

""" md label=prob,ans

#*P お手軽な極限値の計算

$$ f(x) = \frac{x}{\sin x} + \cos x $$ 

を計算するPython関数をかけ. そして, $x\rightarrow 0$ での極限値を近似せよ. 答えを `f0` という名前の変数に格納せよ.

ヒント: もちろん $f(0)$を直接計算しようとすると0での割り算が発生する. そうする代わりにかなり小さな$h > 0$に対して$f(0 + h)$ を計算すれば, 極限値の近似値が求まる. 高校までのやり方と比べるとあまりに簡単な方法

"""

""" code points=1 w """
""" """

""" code label=ans """
import math
def f(x):
    return x / math.sin(x) + math.cos(x)

f0 = f(0.001)
""" """

""" md label=prob,ans
* 以下の math.isclose($x$, $y$, rel_tol=1.0e-3) は, xとyの相対誤差 ($|x-y|/\max(|x|,|y|)$) $< 10^{-3}$のときに真を返す
"""

""" code points=1 label=prob,ans """
# test
assert(math.isclose(f0, 2.0, rel_tol=1.0e-3))
""" """


""" md label=prob,ans

#*P 微分係数の計算

微分係数の定義:
$$ f'(a) = \lim_{h\rightarrow 0} \frac{f(a + h) - f(a)}{h} $$
に従えば，$h$を0に近い数(例えば0.001)に対して，
$$ f'(a) \approx \frac{f(a + h) - f(a)}{h} $$
が成り立つ．これを利用して具体的な$a$に対する微分係数の近似値が簡単に計算できる．
難しい記号操作をする必要はなく，必要なのは，$f(a)$の値が計算できる事だけである．

これを利用して，$\log x$の，$x = a$における
微分係数の近似値を求める関数{\tt log\_prime(a)}を書き,
自分の知る事実
$(\log x)' \approx 1/x$であることを, いくつかの$a$に対して確かめてみよ．

注: $h$をいくらにすればよいかについてはあまり深く
悩む必要はないが以下に注意して適度な値を選ぶ.

* $h \rightarrow 0$での極限を知りたいのだから, 一般的には小さい方がよい
* 一方あまり小さくしすぎると, $a + h$の計算が, 計算機が固定の桁数しか表せないことよる「丸め誤差」を起こしてしまい, 逆に誤差が大きくなってしまう (最悪の場合, $a + h = a$になってしまう.  ためしに, $1 + 10^{-16}$ を計算してみよ).  したがって無闇に$h$を小さくすればいいというわけではない.  一般には$a$に比べて$h$が相対的に小さすぎては困る.

"""

""" code points=1 w """
""" """

""" code label=ans """
def log_prime(a):
    h = a * 0.0001
    g = (math.log(a + h) - math.log(a)) / h
    return g

""" """

""" code points=1 label=prob,ans """
# test
import math
def check_log_prime(a):
    return math.isclose(log_prime(a), 1/a, rel_tol=1.0e-3)

assert(check_log_prime(1.0))
assert(check_log_prime(2.0))
assert(check_log_prime(3.0))
assert(check_log_prime(0.1))
assert(check_log_prime(0.01))
assert(check_log_prime(0.001))
""" """
