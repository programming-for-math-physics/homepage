""" md

#* 式

Pythonの色々な式について学ぶ.

# 算術演算や比較式

以下を `Shift + Enter` で実行してみよ.

"""

""" code """
1 + 2
""" """

""" md

以下でも同様で, セルに何かが入力されていたら`Shift + Enter` で実行してみよう.

心構えとしては, 何も考えずに `Shift + Enter` を叩き続けても無意味なので, 

 * 「正しいPythonの式や文」の知識を広げているという(英語の勉強を例文を読みながらやっているときのような)意識で読む
 * 実行したら出てくる結果を予測しながら実行する

途中からは, 自分でセルに(正しく)プログラムを入力する演習が始まる.
"""

""" code """
3 * 4
""" """

""" md

最もよく使うのは以下のような数学でもよく現れる式.
式の優先度は普段数学でおなじみの規則で処理してくれる
"""

""" code """
5 + 6 * 7
""" """

""" md

もちろん小数点付きの数(__浮動小数点数__)も使える
"""

""" code """
1.2 * 3.4
""" """

""" md

割り算をすると結果はひとりでに浮動小数点数になる

"""

""" code """
89 / 10
""" """

""" md

// で, __端数切り捨ての割り算__ になる
"""

""" code """
89 // 10
""" """

""" md

絶対値が非常に小さい(大きい)浮動小数点数は, いわゆる指数表記が便利で, $a \times 10^b$ を $a$ e $b$ のように書く. 以下は, $6.02 \times 10^{23}$ ということ

"""

""" code """
6.02e23
""" """

""" md

$1.60\times 10^{-19}$

"""

""" code """
1.60e-19
""" """

""" md

** は累乗の演算子. $a$ `**` $b$ で $a^b$ が計算できる
"""

""" code """
3 ** 4
""" """

""" md

結果が巨大になってもOK (これは実は当たり前ではなく, 多くのプログラミング言語で備わっている整数は, 扱える数の範囲が決まっておりそれを越えるとエラーになるか, 意図しない結果になる
"""

""" code """
56 ** 78
""" """

""" md

複素数も使える. `1j` がいわゆる虚数単位 ($\sqrt{-1}$). 
数字の後に`j`をつければ純虚数.

"""

""" code """
2j * 3j
""" """

""" code """
(1 + 1.73j) ** 3
""" """

""" md

その他の色々な演算子

余り
"""

""" code """
89 % 10
""" """

""" md

比較. これらを評価(計算)すると比較結果として真理値 (True または False)が得られる

$ < $
"""

""" code """
1 < 2
""" """

""" md

$ \leq $ は `<=`
"""

""" code """
1 <= 2
""" """

""" md

$ > $
"""

""" code """
1 > 2
""" """

""" md

$ \geq $ は `>=`
"""

""" code """
1 >= 2
""" """

""" md

__要注意:__ 一致するかどうかの比較 ($ = $) は, `=` ではなく `==` 
"""

""" code """
1 == 2
""" """

""" md

`=` は後に出てくる「変数への代入」の記号. 以下はエラーになる!
"""

""" code """
# error
1 = 2
""" """

""" md

# 関数(の呼び出し)

四則演算以外の多くの演算が, Pythonでは「関数」として提供されている

"""

""" md
絶対値$|x|$
"""
""" code """
abs(-5)
""" """

""" md
大きい(小さくない)方
"""
""" code """
max(3, 4)
""" """

""" md
小さい(大きくない)方
"""
""" code """
min(3, 4)
""" """

""" md
四捨五入
"""
""" code """
round(1.49)
""" """

""" code """
round(1.5)
""" """

""" md 

以下は予測と違うかも知れない. 2.5 ピッタリのつもりで書いても, コンピュータでは数を2進数で表す関係で僅かな誤差が出ることがある. その結果以下のような結果になることがある.

"""

""" code """
round(2.5)
""" """

""" md

ここでのポイントは, Python言語では色々な計算がこのような共通の記法

関数名(式, 式, 式, ...)

で書ける(絶対値の関数名はabs, 最小値の関数名はmin, ...)ということ. 数学でおなじみの記法とは違うこともある. 

#* 関数呼び出しにまつわる用語

 * このように書かれた式を__「関数適用(式)」__とか__「関数呼び出し(式)」__と言う. 
特にプログラミングの世界では後者の呼び方をすることが多く, 関数呼び出し式を評価することを, 関数を__「呼び出す」__などという.

 * 関数を呼び出す際の入力値 (abs(-5)の-5, min(3, 4)の3や4)のことを, その関数呼び出しの__「引数(argument)」__という. また, 関数呼び出しabsに, 引数-5を__「渡した」__などという.

 * 関数を呼び出した結果の値(abs(-5)であれば5, min(3, 4)であれば3)のことをその関数の__「返り値(return value)」__という. また, abs(-5)という関数呼び出しが5という値を__「返した」__などという

一般にプログラミングの世界では

```
abs(-5)
```

などの関数を含んだ式を計算することを, 色々な「動作」を想起させる言葉で表現する. 

この式は, 

 * absに, -5を__渡して__, __呼び出す__
 * (呼び出された)absは, 5を__返す__

という具合. 数学で $|x|$ や$\sin x$と書いた時にそのような表現をする人はいないし, そうする必要もない. なぜプログラミングではそうしたくなるのか(そう思っておくことが有用なのか)は後にわかる. 今は, 関数の式を見るとついそういうことをイメージしてしまう, 変わった人種が世の中には(ほぼ, プログラミングをする人の数だけ)いると思っていれば良い.

これまでに見せた算術式や比較式, 関数呼び出し式はすべて式の一種で両者を自由に組み合わせて複雑な式を作ることができる.

"""

""" code """
min(abs((1+2j)**10), abs((1+1j)**20))
""" """

""" md

# モジュール(機能)のimport (輸入)

Pythonには様々な関数が備わっており, 高校までの数学で普段使うような関数は大概備わっている. ただしそれらはある「おまじない」を唱えないと使えない.

例えば$\sin$関数くらい使えるだろうと思って以下を実行するとエラーになる

"""

""" code """
# error
sin(3.0)
""" """

""" md
## import の基本

これを解決するためには以下の「おまじない」を唱える

"""

""" code """
import math
""" """

""" md

このおまじないを唱えると, `math.sin` という名前でで sin関数をつけるようになる

"""

""" code """
math.sin(3.0)
""" """

""" md

ポイントは二つで,

 * `import math` によって `math` という__モジュール__ (あるひとかたまりの機能を備えた「部品」だと思えば良い)を実行中のプログラムに「仕入れ」てくる. 

 * `math`というモジュールには数学でよく使う関数($\sin$, $\cos$など)が揃っている. それらにアクセスするためには, `math.sin`, `math.cos` のように, モジュール名.関数名という表記を用いる. 

比喩としては, モジュール名(math)が名字, その中の関数名が名前に相当する. 自分の家族でない人を呼ぶときは, フルネームで呼ぶのが基本, ということ. それをせずに, ただただ「あきこちゃん」と呼んでも, 矢田亜希子のことなのか, 和田アキ子のことなのかわからない(または紛らわしい)ので, こうするのが理にかなっている.

色々な数学の関数を試しに使って見る.

なお, `import math`をあるセルで実行したら他のセルでも`math`モジュールが使えるようになる. 上記のセルを実行していれば以下は(エラーにならずに)実行できるはずである. エラーになったら`import math`を実行せよ.

"""

""" md

$\cos$
"""

""" code """
math.cos(3.14)
""" """

""" md

$\sin$
"""

""" code """
math.sin(1.57)
""" """

""" md

$\sqrt{x}$
"""

""" code """
math.sqrt(1.44)
""" """

""" md

$e^x$
"""

""" code """
math.exp(3.1)
""" """

""" md

$\log_e x$
"""

""" code """
math.log(10)
""" """

""" md

Pythonには多数のモジュールが最初から提供されており, すべてmathモジュールと同様の手順で使えるようになる. 

 * Pythonに組み込みのモジュール一覧は https://docs.python.org/ja/3/library/index.html
 * 組み込みで提供されていないが, 追加でインストールするなどすれば使えるようになるモジュールは, 無数にある. この初年次ゼミで使う, VPython, numpy, scipy, matplotlibなどもすべて, モジュールとして提供されている.

"""


""" md

なおこのへんで一応注意しておくと, 数学だと普通は $\cos x$と書くところがPython (プログラミング言語)では, `math.cos(x)`  (括弧が必須)だったり, 数学とにているが違うところが各所にある. 

そこは「郷に入っては郷に従え」で, あるプログラミング言語が文法を定めている以上それに厳密に従わなくてはならない. 人間のように書いた人の意図を読んで気を利かせてくれるということはない.

"""

""" md

## 様々なimportの方法

あるモジュールを使いたくなったら, `import モジュール名` とするのが基本だが, 他のimportの記法もある. 何も面倒な使い分けをしなくてもこの基本のやり方で全て押し通せば充分なのだが, この初年次ゼミで使う numpy, matplotlib, vpythonはどういうわけか世の中の本や紹介記事ではどれも特定の記法でやっているので, このゼミでもそれらに合わせる. そこでそれら記法を一応説明しておく.

以下は全て, mathモジュールをimportし, その中の`pi`や`sin`をアクセスるための記法である.

"""

""" md

### 基本形
"""

""" code """
import math
math.pi
math.sin(math.pi/2)
""" """

""" md

### mathの代わりに自分の好きな名前(普通は短い名前)で使えるようにする
"""

""" code """
import math as m
m.pi
m.sin(m.pi/2)
""" """

""" md

### モジュール名を省略する

"""

""" code """
from math import *
pi
sin(3.0)
""" """

""" md

### モジュール名を省略する. ただし, 特定の名前だけを使えるようにする

"""

""" code """
from math import pi,sin
pi
sin(3.0)
""" """

""" md

なお, 3番目のやり方は一見すると便利そうであるが, 複数のモジュールから同じ名前が提供されている場合があり, そのような場合に名前衝突がおき, 意図しないモジュールの機能を使ってしまう危険があるのであまり無闇に使うべきではない.

本初年次ゼミで使う, numpy, matplotlib, vpythonはそれぞれ以下のようにimportするのが, 世の中(世の中でこれらについて説明してある文書)での慣例になっているようである.
"""

""" code """
import numpy as np
import matplotlib.pyplot as plt
from vpython import *
""" """

""" md

# dir関数

`dir(...)` という特別な関数は, あるモジュールの中にどのような関数(後述するが正確には「変数」)が入っているか, 比喩で言うならば家族構成(家族に何君または何ちゃんがいるか)を列挙してくれる. たとえば`math`の中には, $\cos$, $\sin$, $\exp$, $\log$以外にも色々あるはずだ, さて何があるのだろうと思ったら以下のようにする.

"""

""" code """
dir(math)
""" """

""" md

見ての通り, `acos` ($\arccos$), `ceil` ($\lceil x \rceil$), `sinh` ($\sinh$)など様々な関数があることがわかる.

`dir`関数は普段数学で使う関数とはだいぶ趣きが異なるが, 要するに, なにか入力(今の場合, モジュールそのものが入力であった)を与えるとそれに応じて結果(今の場合, 「そのモジュールに含まれた関数名すべて」)が定まるあらゆるものが関数なので, プログラミング言語ではそれらを特に区別なく全て関数と呼んでいる.

"""

""" md

# help関数

あるモジュールや関数に対して, `help(...)` を実行すると(これもまた関数), 与えた入力に関するヘルプ情報(関数であればその使い方など)を表示してくれる.

"""

""" code """
help(math.sin)
""" """


""" md label=prob,ans

#*P 算術式とimportの練習

* https://docs.python.org/ja/3.8/library/math.html を見ながら, 以下を計算する式をPythonで書いて, 実際に答えを出してみよ

"""

""" md label=prob,ans
* 100の階乗 100! ($= 100 \cdot 99 \cdot \cdots \cdot 2 \cdot 1$) は10進数で何桁か?
"""

""" code points=1 w """
""" """

""" code label=ans """
math.floor(math.log10(math.factorial(100))) + 1
""" """

""" md label=ans

#* コメント

* 落とし穴1 : `math.log` は $e$ を底とした対数. 10 を底とした対数は, `math.log(x, 10)` とするか, `math.log10(x)`
* 細かい落とし穴2: logで発生した小数点をどう処理すれば正しい桁数になるのか?

* $x$が$n$桁の整数なのは, $10^{n-1} \leq x < 10^n$ のとき.
$$ \begin{array}{rcl} 10^{n-1} \leq x < 10^n & \iff & n - 1 \leq \log_{10} x < n \end{array} $$
* なので一見すると小数点以下を切り上げれば($\lceil r \rceil$) ただしく$n$が求まる気がするが, 注意してみると, $\log_{10} x$がぴったり整数になるときは正しくない
* 正しい処理は, 切り捨てた後 1 を足す ($\lfloor x \rfloor + 1$) ことである

"""

""" md label=prob,ans
* 3辺の長さが5, 6, 7の三角形で, 長さ5と6の辺の間の角度は約何度か?
"""

""" code points=1 w """
""" """

""" code label=ans """
math.degrees(math.acos((5*5 + 6*6 - 7*7)/(2*5*6)))
""" """

""" md label=prob,ans
* ${}_{2021}\mbox{C}_{37}$を4で割ったあまりはいくらか?
"""

""" code points=1 w """
""" """

""" code label=ans """
math.comb(2021, 37) % 4
""" """

""" md label=ans 

#* コメント

* ${}_{n}\mbox{C}_{r}$ そのものを計算する関数(comb)が備わっているのでそれを使って, あまりは % で求めてもらえばよいというつもりだったが, 他にもやり方があるので結果として割と落とし穴の多い問題になった
* どちらの落とし穴も本質的には同じ理由で生ずるもので, それはそれで教育的なので解説する

"""

""" md label=ans

##* 別法1: あまりをもとめるのに `math.remainder` 関数を使う

"""

""" code label=ans """
math.remainder(math.comb(2021, 37), 4)
""" """

""" md label=ans

* すると答えは 0.0 と出る
* これは2つの理由で起きる 
  * `math.remainder(x, y)` が, 計算をする際にx, yを小数点数つきの数, 正確には「浮動小数点数」に変換してから計算する
  * sinやlogなども同様のことをする
  * 「浮動小数点数」は表現できる桁数に限界があり, 巨大な整数を正確に表すことができない (下の何桁かが切り捨てられてしまう)
  * コンピュータには浮動小数点数を高速に扱うハードウェアが備わっているため計算にはしばしば浮動小数点数が使われる(そもそも無理数など, 有限桁数ではどうやっても正確に表しようのない数があるので適度なところで妥協しなくてはならない)
* 今の場合, x が巨大なので上記のような限界に引っかかってしまう

* 「浮動小数点数」が数をどのように表現しているかを(多少端折って)説明すると, 

$$\pm 1.ddd \cdots ddd \times 2^{nnn \cdots nnn}$$

という形ですべての数を表現している. ここで,
 * $ddd ... ddd$ の部分は2進数で52 桁,
 * $nnn ... nnn$ は2進数で11桁 (うち1桁は正負の符号を表す)
と決まっている. 
* 負の数をどうするとか, 0をどうするかとか細かい話はあるが省略(<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank">詳細</a>).

* したがって大きな整数は, 1ddd ... ddd (合計53桁) までの整数しか正確に表せない
* つまり正確に表せる整数の最大値は, 
$$ 1.111 \cdots 111 \times 2^{53} = 2^{54} - 1$$ 
までということになる
* それを超えると, 下の方の桁が0になったのと同じになる

* そのことは以下のようにして確かめられる
* float(x) は x を浮動小数点数に変換する関数

* $2^{54} - 2 = 2^{54} - 1$ か?

"""

""" code label=ans """
float(2 ** 54 - 2) == float(2 ** 54 - 1)
""" """

""" md label=ans
* $2^{54} - 1 = 2^{54}$ か?
"""

""" code label=ans """
float(2 ** 54 - 1) == float(2 ** 54)
""" """

""" code label=ans """
float(2 ** 54 - 0) - float(2 ** 54 - 1)
""" """

""" md label=ans 

* floatを使わなければこのようなことはおきない

"""

""" code label=ans """
(2 ** 54) - (2 ** 54 - 1)
""" """

""" md label=ans 

* なおこれはコンピュータが, 整数ならいくらでも桁数の多い値を表せるハードウェアを備えているということではなく, Pythonが桁数の大きい整数になったら複数の(桁数の限られた)整数をつなぎ合わせて(例えば 64 桁の整数を2つあわせれば 128 桁分の整数が表せる)大きな数を表しているからできることである
* 他の言語の整数ではこうはならないことが普通なので注意が必要

"""

""" md label=ans

##* 別法2: combを使わずに, factorial とわり算を使う

$${}_{n}\mbox{C}_{r} = \frac{n!}{r! (n-r)!}$$

だから, `math.factorial`を使って以下のようにする

"""

""" code label=ans """
(math.factorial(2021) / (math.factorial(37) * math.factorial(2021 - 37))) % 4
""" """

""" md label=ans

* こちらも答えは0.0 と出てしまう
* 理由もほとんど同じで `/` が「答えを浮動小数点数で求める」と決まっているため
* すなわち上記は以下と同じこと. そしてそれが正しく答えを求められない理由も別法1と全く同じ

"""

""" code label=ans """
float(math.factorial(2021) / (math.factorial(37) * math.factorial(2021 - 37))) % 4
""" """

""" md label=ans

* この方針で正しく答えを求めるには `/` を `//` に置き換える
* `//` は「答えを整数で求める割り算」(端数は切り捨てる)

"""

""" code label=ans """
math.factorial(2021) // (math.factorial(37) * math.factorial(2021 - 37)) % 4
""" """
